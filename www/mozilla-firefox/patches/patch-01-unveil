$OpenBSD$

https://bugzilla.mozilla.org/show_bug.cgi?id=1580271

--- dom/ipc/ContentChild.cpp.orig	Tue Sep 10 20:12:50 2019
+++ dom/ipc/ContentChild.cpp	Tue Sep 10 20:14:03 2019
@@ -4050,22 +4050,35 @@
 #if defined(__OpenBSD__) && defined(MOZ_SANDBOX)
 #  include <unistd.h>
 
+#define MAXTOKENS       3
+#define _UNVEIL_MAIN    "/etc/firefox/unveil.main"
+#define _UNVEIL_CONTENT "/etc/firefox/unveil.content"
+#define _UNVEIL_GPU     "/etc/firefox/unveil.gpu"
+
 static LazyLogModule sPledgeLog("SandboxPledge");
 
 bool StartOpenBSDSandbox(GeckoProcessType type, char *passedPledge) {
   nsAutoCString promisesString;
   nsAutoCString processTypeString;
+  FILE *fp;
+  char *line = NULL, *home = NULL, **ap, *tokens[MAXTOKENS];
+  size_t linesize = 0, lineno = 0;
+  ssize_t linelen;
+  char path[PATH_MAX];
+  const char *ufile;
 
   switch (type) {
     case GeckoProcessType_Default:
       processTypeString = "main";
       Preferences::GetCString("security.sandbox.pledge.main", promisesString);
+      ufile = _UNVEIL_MAIN;
       break;
 
     case GeckoProcessType_Content:
       processTypeString = "content";
       Preferences::GetCString("security.sandbox.pledge.content",
                               promisesString);
+      ufile = _UNVEIL_CONTENT;
       break;
 
     case GeckoProcessType_GPU:
@@ -4074,11 +4087,63 @@
         mozilla::ipc::FatalError("no pledge argument passed to GPU process",
           false);
       promisesString = passedPledge;
+      ufile = _UNVEIL_GPU;
       break;
 
     default:
       MOZ_ASSERT(false, "unknown process type");
       return false;
+  }
+
+  if (!PR_GetEnv("MOZ_DISABLE_UNVEIL")) {
+    fp = fopen(ufile, "r");
+    if (fp == NULL)
+      mozilla::ipc::FatalError(nsPrintfCString("failed to open %s (errno %d)",
+        ufile, errno).get(), false);
+
+    while ((linelen = getline(&line, &linesize, fp)) != -1) {
+      lineno++;
+      if (line[0] == '#' || line[0] == '\n')
+        continue;
+
+      if (line[linelen - 1] == '\n')
+        line[linelen - 1] = '\0';
+
+      for (ap = tokens; ap < &tokens[MAXTOKENS - 1] &&
+       (*ap = strsep(&line, " \t")) != NULL;) {
+        if (**ap != '\0')
+          ap++;
+      }
+      *ap = NULL;
+
+      if (tokens[1] == NULL)
+        mozilla::ipc::FatalError(nsPrintfCString("%s line %zu: must supply "
+          "value", ufile, lineno).get(), false);
+
+      if (tokens[0][0] == '~') {
+        if ((home = getenv("HOME")) == NULL || *home == '\0')
+          mozilla::ipc::FatalError("failed to getenv(HOME)", false);
+
+        memmove(tokens[0], tokens[0] + 1, strlen(tokens[0]));
+        strncpy(path, home, sizeof(path) - 1);
+        path[sizeof(path) - 1] = '\0';
+        strncat(path, tokens[0], sizeof(path) - 1 - strlen(path));
+      } else {
+        strncpy(path, tokens[0], sizeof(path) - 1);
+        path[sizeof(path) - 1] = '\0';
+      }
+
+      if (unveil(path, tokens[1]) == -1)
+        mozilla::ipc::FatalError(nsPrintfCString("failed to unveil(%s, %s)",
+          path, tokens[1]).get(), false);
+      else
+        MOZ_LOG(sPledgeLog, LogLevel::Debug,
+          ("unveiling %s with permissions %s\n", path, tokens[1]));
+    }
+
+    if (line)
+      free(line);
+    fclose(fp);
   }
 
   if (!PR_GetEnv("MOZ_DISABLE_PLEDGE")) {
